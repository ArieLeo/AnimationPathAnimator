using OneDayGame.LoggingTools;
using System;
using UnityEditor;
using UnityEngine;

namespace OneDayGame.AnimationPathTools {

    /// <summary>
    /// Editor for AnimationPath class.
    /// </summary>
    /// <remarks>
    /// It is composed of AnimationPathHandles class that is responsible for
    /// drawing handles, buttons and labels.
    /// </remarks>
    [CustomEditor(typeof(AnimationPath))]
    public class AnimationPathEditor : GameComponentEditor {

        #region Composite Object

        /// <summary>
        /// Object responsible for drawing on-scene handles.
        /// </summary>
        private AnimationPathHandles animationPathHandles =
            ScriptableObject.CreateInstance<AnimationPathHandles>();

        #endregion Composite Object

        #region Keyboard Keys

        /// <summary>
        /// If draw tools key is pressed in this frame.
        /// </summary>
        private bool drawToolsKeyPressed = false;

        /// <summary>
        /// If handles mode key is pressed in this frame.
        /// </summary>
        private bool handlesModeKeyPressed = false;

        /// <summary>
        /// If move all mode key is pressed in this frame.
        /// </summary>
        private bool moveAllKeyPressed = false;

        /// <summary>
        /// If draw tools key was pressed in the previous frame.
        /// </summary>
        private bool prevDrawToolsKeyValue = false;

        /// <summary>
        /// If handles mode key was pressed in the previous frame.
        /// </summary>
        private bool prevHandlesModeKeyValue = false;

        /// <summary>
        /// If move all mode key was pressed in the previous frame.
        /// </summary>
        private bool prevMoveAllKeyValue = false;

        #endregion Keyboard Keys

        #region Serialized Properties

        private SerializedProperty advancedSettingsFoldout;
        private SerializedProperty autoDistributeMode;
        private SerializedProperty autoLinearMode;
        private SerializedProperty displaySpeedLabel;
        private SerializedProperty displayTimeLabel;
        private SerializedProperty drawAddButtons;
        private SerializedProperty drawHandles;
        private SerializedProperty drawHandlesModeIndicator;
        private SerializedProperty drawLinearTangentModeButton;
        private SerializedProperty drawMovementModeIndicator;
        private SerializedProperty drawPathTools;
        private SerializedProperty drawRemoveButtons;
        private SerializedProperty drawSmoothTangentButton;
        private SerializedProperty enableGOHandle;
        private SerializedProperty exportSamplingFrequency;
        private SerializedProperty gizmoCurveColor;
        private SerializedProperty moveAllMode;
        private SerializedProperty samplingFrequency;
        private SerializedProperty skin;
        private SerializedProperty tangentMode;
        private SerializedProperty tangentWeight;

        #endregion Serialized Properties

        #region Helper Variables

        /// <summary>
        /// Scene tool that was selected when game object was first selected in
        /// the hierarchy view.
        /// </summary>
        private Tool lastTool = Tool.None;

        /// <summary>
        /// Value of <c>enableGOHandle</c> from previous frame.
        /// </summary>
        private bool prevEnableGOHandle = true;

        /// <summary>
        /// Reference to serialized class.
        /// </summary>
        private AnimationPath script;

        #endregion Helper Variables

        #region Public Methods

        void OnDisable() {


            // When used selects other game object in the scene view, restore
            // previously used scene tool.
            ShowGOHandle();
        }

<<<<<<< Updated upstream
        public override void OnEnable() {
            script = (AnimationPath)target;
            lastTool = Tools.current;
=======
        void OnEnable() {

>>>>>>> Stashed changes

            // Initialize serialized properties.
            gizmoCurveColor = serializedObject.FindProperty("gizmoCurveColor");
            skin = serializedObject.FindProperty("skin");
            drawHandles =
                serializedObject.FindProperty("drawHandles");
            displayTimeLabel = serializedObject.FindProperty("displayTimeLabel");
            displaySpeedLabel =
                serializedObject.FindProperty("displaySpeedLabel");
            enableGOHandle = serializedObject.FindProperty("enableGOHandle");
            autoLinearMode = serializedObject.FindProperty("autoLinearMode");
            autoDistributeMode =
                serializedObject.FindProperty("autoDistributeMode");
            samplingFrequency =
                serializedObject.FindProperty("samplingFrequency");
            exportSamplingFrequency =
                serializedObject.FindProperty("exportSamplingFrequency");
            tangentWeight = serializedObject.FindProperty("tangentWeight");
            drawAddButtons =
                serializedObject.FindProperty("drawAddButtons");
            drawRemoveButtons =
                serializedObject.FindProperty("drawRemoveButtons");
            drawSmoothTangentButton =
                serializedObject.FindProperty("drawSmoothTangentButton");
            drawHandlesModeIndicator =
                serializedObject.FindProperty("drawHandlesModeIndicator");
            drawMovementModeIndicator =
                serializedObject.FindProperty("drawMovementModeIndicator");
            advancedSettingsFoldout =
                serializedObject.FindProperty("advancedSettingsFoldout");
            moveAllMode =
                serializedObject.FindProperty("moveAllMode");
            tangentMode = serializedObject.FindProperty("tangentMode");
            drawPathTools =
                serializedObject.FindProperty("drawPathTools");
            drawLinearTangentModeButton =
                serializedObject.FindProperty("drawLinearTangentModeButton");
        }

        void OnInspectorGUI() {


            // Update serialized properties.
            serializedObject.Update();

            // Draw inspector GUI elements.
            DrawInspectorGUI();

            // Handle toggling animation path tools with keyboard shortcut.
            UpdatePathToolsOption();

            // Toggle all path tools depending on inspector "Draw Tools"
            // option's value.
            UpdatePathToolsState();

            // Handle toggling handle mode with keyboard shortcut.
            UpdateTangentModeOption();

            // Handle toogling move all mode with keyboard shortcut.
            UpdateMoveAllModeOption();

            // Save serialized properties.
            serializedObject.ApplyModifiedProperties();

            // Save changes
            /*if (GUI.changed) {
                EditorUtility.SetDirty(script);
            }*/
        }

        void OnSceneGUI() {


            // Log error if inspector GUISkin filed is empty.
            if (script.Skin == null) {
                script.MissingReferenceError(
                        "Skin",
                        "Skin field cannot be empty. You will find default " +
                        "GUISkin in the Animation PathTools/GUISkin folder");
            }

            // Return if curves are not initialized.
            if (script.NodesNo < 2) {
                return;
            }

            // Make snapshot of the target object.
            HandleUndo();

            // Update shortcut keys state for this frame.
            AnimationPathUtilities.UpdateKeyboardKey(
                AnimationPath.MoveAllKey,
                ref moveAllKeyPressed,
                ref prevMoveAllKeyValue);

            AnimationPathUtilities.UpdateKeyboardKey(
                AnimationPath.HandlesModeKey,
                ref handlesModeKeyPressed,
                ref prevHandlesModeKeyValue);

            AnimationPathUtilities.UpdateKeyboardKey(
                AnimationPath.DrawToolsKey,
                ref drawToolsKeyPressed,
                ref prevDrawToolsKeyValue);

            // Update nodes in AnimationPathHandles class.
            //
            // Those nodes will be used to draw all on-scene elements.
            //HandleInitNodes();

            // Hide scene tool.
            // 
            // By default, all game objects have an on-scene tool enabled
            // (movement, rotation, scale, ...). This method will toggle

            HandleEnableGOHandleOption();

            // Update "Path Tools" inspector option with keyboard shortcut.
            UpdatePathToolsOption();

            // If "Path Tools" inspector option is enabled, enable all on-scene
            // node's tools. Disable otherwise.
            UpdatePathToolsState();

            // Change handles mode.
            // 
            // Each on-scene node has a handle to update node's attribute.

            // mode. See HandlesMode enum for available tools.
            UpdateTangentModeOption();

            // Update "Move All" inspector option with keyboard shortcut.
            UpdateMoveAllModeOption();

            // Handle drawing movement handles.
            HandleDrawingMovementHandles();

            // Handle displaying tangent handles.
            // 
            // Tangent handles allows changing nodes' in/out tangents.
            HandleDrawingTangentHandles();

            // Handle drawing for each node an indicator of currently active
            // handles mode.
            HandleDrawingHandlesModeIndicator();

            // Handle drawing for each node an indicator of currently active
            // movement mode.
            HandleDrawingMovementModeIndicator();

            // Handle drawing for each node timestamp label.
            HandleDrawingTimestampLabels();

            // Handle drawing speed label for each node.
            HandleDrawingSpeedLabels();

            // Draw add node buttons.
            HandleDrawingAddButtons();

            // Draw remove node buttons.
            HandleDrawingRemoveButtons();

            // Handle drawing smooth tangent button for each node.
            HandleDrawingSmoothTangentButton();

            // Handle drawing button that changes node's tangent mode to
            // linear.
            HandleDrawingLinearTangentModeButton();
        }

        #endregion Public Methods

        #region Private Methods

        private void DrawAddNodeButtonsCallbackHandler(int index) {
            // Add a new node.
            script.AddNodeAuto(index);

            // Handle distributing timestamps evenly.
            HandleAutoDistributeOption();
        }

        private void DrawInspectorGUI() {
            EditorGUILayout.PropertyField(
                    gizmoCurveColor,
                    new GUIContent("Curve Color", ""));

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent(
                "Distribute",
                "Distribute node timestamps evenly."))) {

                script.DistributeNodesEvenlyInTime();
            }
            if (GUILayout.Button(new GUIContent(
                "Linear",
                "Set tangent mode to linear for all nodePositions."))) {

                script.SetNodesLinear();
            }
            if (GUILayout.Button(new GUIContent(
                "Create/Reset",
                "Create a new default Animation Path or reset to default."))) {

                // Allow undo this operation.
                HandleUndo();

                // Reset curves to its default state.
                script.ResetPath();
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 50;
            tangentWeight.floatValue = EditorGUILayout.FloatField(
                    new GUIContent(
                        "Weight",
                        "Weight to apply to the tangents."
                        ),
                    tangentWeight.floatValue);
            if (GUILayout.Button(new GUIContent(
                "Smooth Tangents",
                "Use AnimationCurve.SmoothNodesTangents on every node in the path."))) {

                HandleUndo();

                script.SmoothNodesTangents(tangentWeight.floatValue);
            }
            EditorGUIUtility.labelWidth = 0;
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.Space();

            // Tooltip for moveAllMode property.
            string moveAllModeTooltip = String.Format(
                "If enabled, you can move with mouse all nodePositions at once. " +
                "Toggle it with {0} key.",
                AnimationPath.MoveAllKey);

            EditorGUILayout.PropertyField(
                moveAllMode,
                new GUIContent(
                    "Move All",
                    moveAllModeTooltip));

            // Tooltip for drawPathTools property.
            string drawPathToolsTooltip = String.Format(
                "Show/hide on-scene node tools. " +
                "Toggle it with {0} key.",
                AnimationPath.DrawToolsKey);

            EditorGUILayout.PropertyField(
                    drawPathTools,
                    new GUIContent(
                        "Draw Tools",
                        drawPathToolsTooltip));

            // Tooltip for handlesMode property.
            string tangentModeTooltip = String.Format(
                "If enabled, the on-scene handles will change node's tangents." +
                "Enable it temporarily with {0} key.",
                AnimationPath.HandlesModeKey);

            // Deactive tangent mode toggle when auto linear mode is enabled.
            if (autoLinearMode.boolValue == true) {
                GUI.enabled = false;
                tangentMode.boolValue = false;
            }

            EditorGUILayout.PropertyField(
                tangentMode,
                new GUIContent(
                    "Tangent Mode",
                    tangentModeTooltip));

            // Make all other controls active.
            GUI.enabled = true;

            EditorGUILayout.PropertyField(
                autoLinearMode,
                new GUIContent(
                    "Auto Linear Mode",
                    "If enabled, tangent mode for the moved node and its " +
                    "neighbors will be set to linear."));

            EditorGUILayout.PropertyField(
                autoDistributeMode,
                new GUIContent(
                    "Auto Distribute Mode",
                    "If enabled, adding/removing nodes will cause distributing" +
                    "their timestamps evenly."));

            EditorGUILayout.Space();

            EditorGUILayout.PropertyField(
                    exportSamplingFrequency,
                    new GUIContent(
                        "Export Sampling",
                        "Number of points to export for 1 m of the curve. " +
                        "If set to 0, it'll export only keys defined in " +
                        "the curve."));
            if (GUILayout.Button("Export Nodes")) {
                script.ExportNodes(exportSamplingFrequency.intValue);
            }
            EditorGUILayout.Space();

            advancedSettingsFoldout.boolValue = EditorGUILayout.Foldout(
                    advancedSettingsFoldout.boolValue,
                    new GUIContent(
                        "Advanced Settings",
                        ""));
            if (advancedSettingsFoldout.boolValue == true) {
                EditorGUILayout.PropertyField(
                        samplingFrequency,
                        new GUIContent(
                            "Curve Sampling",
                            "Number of points to draw 1 m of gizmo curve."));
                EditorGUILayout.PropertyField(
                        skin,
                        new GUIContent(
                            "Skin",
                            "Styles used by on-scene GUI elements."));
                EditorGUILayout.PropertyField(
                        enableGOHandle,
                        new GUIContent(
                            "Enable GO Handle",
                            "Show default GO handle. If this GO has more than " +
                            "one AnimationPath component attached, then all " +
                            "of them must have this option enabled in order " +
                            "to take effect."));
            }
        }

        private void DrawMovementHandlesCallbackHandler(
            int movedNodeIndex,
            Vector3 position,
            Vector3 moveDelta) {

            // Change position of a single or all nodes.
            if (moveAllMode.boolValue == true) {
                script.MoveAllNodes(moveDelta);
            }
            else {
                script.MoveNode(movedNodeIndex, position);
            }

            HandleAutoLinearOption(movedNodeIndex);
        }

        private void HandleAutoDistributeOption() {
            // Return if option disabled in the inspector.
            if (autoDistributeMode.boolValue == false) {
                return;
            }

            // Distribute timestamps.
            script.DistributeNodesEvenlyInTime();
        }

        /// <summary>
        /// Handle Auto Linear mode.
        /// </summary>
        /// <param name="movedNodeIndex"></param>
        private void HandleAutoLinearOption(int movedNodeIndex) {
            // If node was moved and auto linear inspector option is enabled..
            if (autoLinearMode.boolValue == false) {
                return;
            }

            script.SetLinearSelfAndNeighbors(movedNodeIndex);
        }

        private void HandleDrawingAddButtons() {
            // Return if drawing add/remove buttons option is disabled.
            if (drawAddButtons.boolValue != true) {
                return;
            }

            // Positions at which to draw movement handles.
            Vector3[] nodes = script.GetNodePositions();

            // Get style for add button.
            GUIStyle addButtonStyle = script.Skin.GetStyle(
                        "AddButton");

            // Callback to add a new node after add button was pressed.
            Action<int> handlerCallback =
                (index) => DrawAddNodeButtonsCallbackHandler(index);

            // Draw add node buttons.
            animationPathHandles.DrawAddNodeButtons(
                nodes,
                handlerCallback,
                addButtonStyle);
        }

        /// <summary>
        /// Handle drawing handles mode indicator.
        /// </summary>
        private void HandleDrawingHandlesModeIndicator() {
            // Draw tangent mode indicator only when tangent mode enabled.
            if (drawHandlesModeIndicator.boolValue == false) {
                return;
            }

            // Tangent mode indicator style;
            GUIStyle style = script.Skin.GetStyle(
                        "TangentModeIndicator");

            // Positions at which to draw movement handles.
            Vector3[] nodes = script.GetNodePositions();

            // Draw label for Movement mode.
            if (tangentMode.boolValue == false) {
                animationPathHandles.DrawLabelForEachNode(
                    nodes,
                    style,
                    "M",
                    30,
                    6,
                    25,
                    25);
            }
            // Draw label for Tangent mode.
            else {
                animationPathHandles.DrawLabelForEachNode(
                    nodes,
                    style,
                    "T",
                    30,
                    6,
                    25,
                    25);
            }
        }

        /// <summary>
        /// Handle drawing linear tangent mode button.
        /// </summary>
        private void HandleDrawingLinearTangentModeButton() {
            // Return if drawing Linear Tangent Mode button is disabled.
            if (drawLinearTangentModeButton.boolValue == false) {
                return;
            }

            // Get button style.
            GUIStyle buttonStyle = script.Skin.GetStyle(
                        "LinearTangentModeButton");

            // Positions at which to draw movement handles.
            Vector3[] nodePositions = script.GetNodePositions();

            // Callback to smooth a node after smooth node button was pressed.
            Action<int> setNodeLinearCallback =
                (index) => script.SetNodeLinear(index);

            // Draw button.
            animationPathHandles.DrawLinearTangentModeButtons(
                nodePositions,
                buttonStyle,
                setNodeLinearCallback);
        }

        /// <summary>
        /// Handle drawing movement handles.
        /// </summary>
        private void HandleDrawingMovementHandles() {
            // Draw handles if enabled in the inspector and tangent mode is
            // disabled.
            if (drawHandles.boolValue == false ||
                tangentMode.boolValue == true) {

                return;
            }

            // Positions at which to draw movement handles.
            Vector3[] nodes = script.GetNodePositions();

            // Callback to call when a node is moved on the scene.
            Action<int, Vector3, Vector3> handlerCallback =
                (index, newPosition, moveDelta) =>
                    DrawMovementHandlesCallbackHandler(
                        index,
                        newPosition,
                        moveDelta);

            // Draw handles.
            animationPathHandles.DrawMovementHandles(nodes, handlerCallback);
        }

        /// <summary>
        /// Handle drawing Move mode indicator.
        /// </summary>
        private void HandleDrawingMovementModeIndicator() {
            // Draw tangent mode indicator only when tangent mode enabled.
            if (drawMovementModeIndicator.boolValue == false) {
                return;
            }

            // Draw label for Move All mode. TODO Add this condition to one
            // above.
            if (moveAllMode.boolValue == true) {
                GUIStyle style = script.Skin.GetStyle("MoveAllModeIndicator");

                // Positions at which to draw movement handles.
                Vector3[] nodes = script.GetNodePositions();

                // Draw labels for all nodes.
                animationPathHandles.DrawLabelForEachNode(
                    nodes,
                    style,
                    "A",
                    20,
                    6,
                    25,
                    25);
            }
            // Draw label for Move Single mode.
            else {
                GUIStyle style = script.Skin.GetStyle("MoveSingleModeIndicator");

                // Positions at which to draw movement handles.
                Vector3[] nodes = script.GetNodePositions();

                // Draw labels for all nodes.
                animationPathHandles.DrawLabelForEachNode(
                    nodes,
                    style,
                    "S",
                    20,
                    6,
                    25,
                    25);
            }
        }

        private void HandleDrawingRemoveButtons() {
            // Return if drawing add/remove buttons option is disabled.
            if (drawRemoveButtons.boolValue != true) {
                return;
            }

            // Positions at which to draw movement handles.
            Vector3[] nodes = script.GetNodePositions();

            // Get style for add button.
            GUIStyle removeButtonStyle = script.Skin.GetStyle(
                        "RemoveButton");

            // Callback to add a new node after add button was pressed.
            Action<int> removeNodeCallback =
                (index) => script.RemoveNode(index);

            // Draw add node buttons.
            animationPathHandles.DrawRemoveNodeButtons(
                nodes,
                removeNodeCallback,
                removeButtonStyle);
        }

        /// <summary>
        /// Handle drawing smooth tangent button.
        /// </summary>
        private void HandleDrawingSmoothTangentButton() {
            // Return if not drawing Smooth Tangent button is disabled.
            if (drawSmoothTangentButton.boolValue == false) {
                return;
            }

            // Get button style.
            GUIStyle smoothButtonStyle = script.Skin.GetStyle(
                        "SmoothButton");

            // Positions at which to draw movement handles.
            Vector3[] nodePositions = script.GetNodePositions();

            // Callback to smooth a node after smooth node button was pressed.
            Action<int> smoothNodeCallback =
                (index) => script.SmoothNodeTangents(
                    index,
                    tangentWeight.floatValue);

            // Draw button.
            animationPathHandles.DrawSmoothTangentButtons(
                nodePositions,
                smoothButtonStyle,
                smoothNodeCallback);
        }

        /// <summary>
        /// Handle all actions related to drawing speed labels.
        /// </summary>
        private void HandleDrawingSpeedLabels() {
            // Return if speed labels are disabled in the inspector.
            if (displaySpeedLabel.boolValue != true) {
                return;
            }

            // Return if animation curves are not initialized or if there's not
            // enough nodes to calculate speed. TODO Replace with a call to
            // method in AnimationPath.
            if (script.NodesNo < 2) {
                return;
            }

            // Timestamp label style.
            GUIStyle style = script.Skin.GetStyle("SpeedLabel");

            // Positions at which to draw movement handles.
            Vector3[] nodePositions = script.GetNodePositions();

            // Get speed values.
            float[] speedValues = script.GetSpeedValues();

            // Draw speed labels.
            animationPathHandles.DrawSpeedLabels(
                    nodePositions,
                    speedValues,
                    style);
        }

        /// <summary>
        /// Handle drawing tangent handles.
        /// </summary>
        private void HandleDrawingTangentHandles() {
            // Exit if tangent handles are disabled.
            if (drawHandles.boolValue == false
                || tangentMode.boolValue == false) {

                return;
            }

            // Positions at which to draw tangent handles.
            Vector3[] nodes = script.GetNodePositions();

            // Callback: After handle is moved, update animation curves.
            Action<int, Vector3> updateTangentsCallback =
                (index, inOutTangent) => script.ChangeNodeTangents(
                    index, inOutTangent);

            // Draw tangent handles.
            animationPathHandles.DrawTangentHandles(
                nodes,
                updateTangentsCallback);
        }

        /// <summary>
        /// Handle drawing timestamp labels.
        /// </summary>
        private void HandleDrawingTimestampLabels() {
            // Return if drawing timestamp label is disabled in the inspector.
            if (displayTimeLabel.boolValue == false) {
                return;
            }

            // Timestamp label style.
            GUIStyle style = script.Skin.GetStyle("TimestampLabel");

            // Positions at which to draw movement handles.
            Vector3[] nodes = script.GetNodePositions();

            // Nodes' timestamps.
            float[] timestamps = script.GetNodeTimestamps();

            // Draw timestamp labels.
            animationPathHandles.DrawTimestampLabels(
                    nodes,
                    timestamps,
                    style);
        }

        /// <summary>
        /// Hide default game object handle.
        /// </summary>
        private void HandleEnableGOHandleOption() {
            // If GO handle was enabled in the scene in previous frame..
            if (prevEnableGOHandle == true
                // but just got disabled..
                    && enableGOHandle.boolValue == false
                // and the GO tool wasn't already reseted by some other
                // instance of this script..
                    && Tools.current != Tool.None) {

                // Remember currently active tool.
                lastTool = Tools.current;

                // Set current tool to none.
                Tools.current = Tool.None;

                // Remember inspector option's current state.
                prevEnableGOHandle = enableGOHandle.boolValue;
            }
        }

        /// <summary>
        /// Record target object state for undo.
        /// </summary>
        private void HandleUndo() {
            Undo.RecordObject(
                    serializedObject.targetObject,
                    "Update curves");
        }

        /// <summary>
        /// Enable Unity's scene tool for game object selected in the
        /// inspector.
        /// </summary>
        private void ShowGOHandle() {
            Tools.current = lastTool;
        }

        /// <summary>
        /// Update <c>moveAllMode</c> option with keyboard shortcut.
        /// </summary>
        private void UpdateMoveAllModeOption() {
            // If was pressed..
            if (moveAllKeyPressed == true && prevMoveAllKeyValue == false) {
                // Toggle move all mode.
                moveAllMode.boolValue = !moveAllMode.boolValue;
            }

            // If key was released..
            if (moveAllKeyPressed == false && prevMoveAllKeyValue == true) {
                // Toggle move all mode.
                moveAllMode.boolValue = !moveAllMode.boolValue;
            }
        }

        /// <summary>
        /// Toggle <c>drawPathTools</c> option with keyboard shortcut
        /// <c>AnimationPath.drawPathTools</c>.
        /// </summary>
        private void UpdatePathToolsOption() {
            // If draw tools key was pressed..
            if (drawToolsKeyPressed == true
                && prevDrawToolsKeyValue == false) {

                // Toggle draw tools option.
                drawPathTools.boolValue = !drawPathTools.boolValue;
            }
        }

        /// <summary>
        /// Toggle visibility of all path tools individually.
        /// </summary>
        private void UpdatePathToolsState() {
            // If drawing path tools is enabled.
            if (drawPathTools.boolValue == true) {
                drawHandles.boolValue = true;
                displayTimeLabel.boolValue = true;
                displaySpeedLabel.boolValue = true;
                drawAddButtons.boolValue = true;
                drawRemoveButtons.boolValue = true;
                drawSmoothTangentButton.boolValue = true;
                drawLinearTangentModeButton.boolValue = true;
                drawHandlesModeIndicator.boolValue = true;
                drawMovementModeIndicator.boolValue = true;
            }
            else {
                drawHandles.boolValue = false;
                displayTimeLabel.boolValue = false;
                displaySpeedLabel.boolValue = false;
                drawAddButtons.boolValue = false;
                drawRemoveButtons.boolValue = false;
                drawSmoothTangentButton.boolValue = false;
                drawLinearTangentModeButton.boolValue = false;
                drawHandlesModeIndicator.boolValue = false;
                drawMovementModeIndicator.boolValue = false;
            }

            // If Auto Linear Mode is enabled, hide unnecessary controls.
            if (drawPathTools.boolValue == true
                && autoLinearMode.boolValue == true) {

                drawSmoothTangentButton.boolValue = false;
                drawLinearTangentModeButton.boolValue = false;
                drawHandlesModeIndicator.boolValue = false;
            }
        }

        /// <summary>
        /// Toggle handles mode with key shortcut.
        /// </summary>
        private void UpdateTangentModeOption() {
            // Don't allow changing handles mode to tangent when auto linear
            // mode is enabled. It would take no effect anyway.
            if (autoLinearMode.boolValue == true) {
                return;
            }

            // If modifier key was pressed, toggle handles mode.
            if (handlesModeKeyPressed == true
                && prevHandlesModeKeyValue == false) {

                // Enable Tangent Mode.
                tangentMode.boolValue = true;
            }

            // If key is up, restore previous value.
            if (handlesModeKeyPressed == false
                && prevHandlesModeKeyValue == true) {

                // Disable Tangent Mode.
                tangentMode.boolValue = false;
            }
        }

        #endregion Private Methods
    }
}